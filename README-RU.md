# Демо Telegram Mini App

В этом репозитории представлен пример разработки мини-приложения "Магазин мини приложений" для платформы Telegram. Живая тестовая версия приложения доступна по [этой ссылке](https://t.me/tg_app_store_bot). 

Основные функции:

* просмотр приложений по категориям
* добавление приложений в избранное
* выставление оценки
* запуск приложения прямо из магазина

## Технический стэк

В примере используются следующий технический стэк: HTML, JS, CSS, Kotlin, [Ktor](https://ktor.io/), [Heroku](https://www.heroku.com/).

Для комфортного изучения примера необходимы базовые знания вэб разработки. Достаточно основ владения HTML, JS и CSS. Для понимания работы серверной части желательно владение языком Kotlin на базовом уровне.

# Использование

Данный репозиторий можно использовать как отправную точку при создании своих Telegram Mini App. Исходный код клиента и сервера представляют собой минималистичный набор методов, достатчных для понимания основ разработки собственных приложений. Многие вещи сознательно упрощены, чтобы не перегружать тестовый пример излишними деталями. В то же время сделан акцент на важных нюансах, которые стоит учитывать при разработке собственного приложения.

## Быстрый запуск

Для начала подготовим свою версию проекта и запустим собственную версию бота.

### Форк репозитория

Чтобы была возможность вносить свои изменения и получать обновления создайте форк текущего репозитория.

### Telegram бот

Создайте свой бот в Telegram. Если вы никогда до этого не имели дело с ботами в Telegram, воспользуйтесь одной из инструкцией, например, [этой из официальной документации](https://core.telegram.org/bots/tutorial).

На данном этапе нам достаточно дойти до получения токена, сам код для бота писать не нужно, однако вы всегда можете добавить некоторую функциональность в классический Telegram бот позже.

### Проверка доступности index.html

В отличии от классического Telegram бота, которому важно наличие backend, для работы Telegram Mini App в минимальном варианте достаточно только наличия вэб страницы. Самым простым и бесплатным способом хостинга статических HTML страниц является сам GitHub. Для этого мы будем использовать [GitHub Pages](https://pages.github.com) разместив в нем содержимое нашего каталога webapp. GitHub Pages разрешает размещать такой контент в 2-х местах (на момент написания инструкции): корневая дирректория `/(root)` или дирректория `/docs`. 

Для удобства разделения различных частей проекта наш контент размещается в дирректории `/webapp`. Чтобы он стал доступен для отображения в GitHub Pages, в репозитории используется плагин [GitHub Pages Overwriter](https://github.com/marketplace/actions/github-pages-overwriter). Убедитесь, что он работает корректно во вкладке `Actions` вашего репозитория. 

Если Action отрабатывает с ошибкой, убедитесь, что для Actions включен режим Read and write permissions. Проверить это можно в настройках репозитория по следующему пути: `Settings -> Actions (Code and automation) -> General -> Workflow permissions`. Должно быть выбрано Read and write permissions.

Если публикация прошла успешно, по адресу http://username.github.io/repository (в текущем репозитории это http://landarskiy.github.io/tg-app-store) откроется HTML страница и отобразится контент нашего магазина.

Если по каким-либо причинам после успешного выполнения Action содержимое папки webapp не стало доступно по ссылке GitHub Pages, сверьтесь с инструкцией плагина `GitHub Pages Overwriter`. Обратите внимание, правильно ли вы настроили Pages в вашем репозитории, запускается ли Action при пуше изменений, существует ли ветка, на которую настроен плагин. В крайнем случае рассмотрите вариант перемещение сожержимого из дирректории `/webapp` в дирректорию `/docs`, как того требует GitHub Pages, в этом случае вам не понадобится пользоваться указанным выше плагином.

### Подключение Mini App к боту

Следуя [официальной инструкции](https://core.telegram.org/bots/webapps#launching-mini-apps-from-the-menu-button) добавьте в ранее созданный бот путь к GitHub Pages странице репозитория.

Если всё выполнено верно, можно зайти в ваш бот и открыть в нём приложение магазина через кнопку меню.

Сейчас ваш бот берет данные с сервера основного репозитория. Это значит, что есть вероятность того, что вы не увидите сам контент приложения (имеется ввиду наличие приложений в магазине). Данная ситуация может возникнуть по разным причинам: сервер прекратил работу, временно недоступен и т.д. Однако в любом случае, вне зависимости от доступности сервера источника данных, страница должа быть загружена и корректно отобразиться, пусть и без наполнения. Далее мы рассмотрим то, каким образом можно обойтись на начальном этапе без сервера, сейчас не будем заострять на этом внимание.

Так же вы можете заметить, что некоторые функции, такие как добавление в избранное и проставление оценок работают некорректно. Это происходит из-за того, что на стороне сервера происходит валидация клиента. Данный аспект также будет рассмотрен немного позже.

### Дополнительная информации

Как видно из инструкции, достаточно всего 3-х простых шагов для того, чтобы можно было начать разрабатывать Telegram Mini App. Для этого даже не обязательно писать серверную часть. Например, если вы делаете простое приложение вроде калькулятора, или простую игру, не требующую взаимодействия с сервером, вам не нужно валидировать пользовательские данные и вам достаточно возможностей чистого HTML, JS и CSS, то предыдущих шагов хватит, чтобы ваше приложение успешно функционировало в среде Telegram.

## Подготовка окружения

Для локального запуска backend части необходимо установить:

* Java 17 или выше

Рекомендуемые IDE для работы (вы можете выбрать другие, более привычные для вас):

* [Visual Studio Code](https://code.visualstudio.com/) для работы с frontend частью
* [Intellij Idea Community Edition](https://www.jetbrains.com/help/idea/installation-guide.html) для работы с backend частью

Сервис для развертывания backend (опционально):

* В примере используется [Heroku](https://dashboard.heroku.com/), но подойдёт любая другая аналогичная платформа для развертывания Java приложений

Вы можете запускать серверную часть локально, в этом случае отладку и разработку можно вести в обычном браузере. Стоит учитывать, что в таком режиме ни одно свойство из [telegram-web-app.js](https://core.telegram.org/bots/webapps#initializing-mini-apps) не будет доступно, а методы не будут работать согласно документации. Если вы планируете обращаться к локальному серверу через бота - убедитесь, что сервер будет доступен вне локальной сети. Данная настройка выходит за рамки текущего примера.

## Структура репозитория

Репозиторий содержит 2 основные части: frontend и backend. Структура выглдяит следующим образом:

```
tg-app-store
├─ backend
│  ├─ src
│  │  ├─ ...
│  │  ... 
│  ├─ build.gradle.kts
│  ...
├─ webapp
│  ├─ index.html
│  ├─ css
│  │  ├─ ...
│  │  ...
│  ├─ stub
│  │  ├─ ...
│  │  ...
│  ...
└─ README.md
```

 Где `webapp` это минималистичный вэб-проект (HTML, CSS, JS) без лишних зависимостей, а `backend` - Kotlin Gradle проект, представляющий собой [Ktor](https://ktor.io/) сервер.

## Работа с проектом

С приложением можно работать в 3-х условных режимах: 

* HTML-only песочница, без backend. Данный режим позволяет проверять frontend часть как локально в обычном браузере, так и через приложение Telegram. С помощью этого метода невозможно корректно валидировать пользовательские данные, при добавлении новой функциональности на backend так же необходимо реализовать локальные заглушки в js файлах. 
* песочница с локальным backend-ом. Без дополнительной настройки backend позволяет запускать приложение только локально в обычном браузере, проверка в Telegram требует дополнительную настройку доступности сервера из вне.
* production версия. Как и первый режим позволяет проверять frontend часть как локально в обычном браузере, так и через приложение Telegram. Однако, в отличии от локальной песочницы, этот режим позволяет безопасно проводить валидацию пользовательских данных.

### HTML-only песочница

Данный режим работы с проектом предназначем в первую очередь для вёрстки приложения и тестирования корректности отработки базовых сценариев. 

Идея использования этого режима заключается в том, что мы вместо реальных вызовов методов нашего backend-а используем вызовы локальных функций, которые в упрощённом виде обрабатывают данные и эмулируют ответ реального сервера.

Для того, что в нашем примере воспользоваться этим режимом, необходимо раскоментировать одну строку в файле `index.html`, в итоге он должен выглядеть слебующим образом:

```html
    ...
    <script src="data-repository.js"></script>
    <!-- Uncomment mock-data-repository.js when you would like to test the app in a local sandbox mode, without real requests to the server -->
    <script src="stub/mock-data-repository.js"></script>
    <script src="css/css-class-names.js"></script>
    ...
```

Наше мини-приложение общается с сервером через специальные функции-делегаты, которые определены в другом файле `data-repository.js`. Например, определение метода обращения за списком приложений выглядит следующим образом:

```js
let loadAppListDelegate = function loadAppList(userId, categoryId, initData, successCallback, failCallback) {
    const params = { category_id: categoryId };
    if (userId) {
        params.user_id = userId;
    }
    const query = new URLSearchParams(params);
    fetch(`${configuration.serverUrl}/app/list?${query.toString()}`, buildInitDataPostParams(initData)).then(response => {
        if (!response.ok) {
            throw new Error('Error occured');
        }
        return response.json();
    }).then(data => {
        successCallback(data);
    }).catch(error => {
        failCallback(error);
    });
}
```

В самом приложении мы вызываем метод с помощью переменной `loadAppListDelegate`:

```js
function loadApps(category) {
    loadAppListDelegate(
        window.Telegram.WebApp.initDataUnsafe?.user?.id,
        category,
        initDataProviderDelegate(),
        data => {
            displayApps(data);
        },
        error => { }
    );
}
```

При подключении файла `mock-data-repository.js` эта переменная перезапишется и вместо вызова функции выше будет вызвана другая функция, переопределенная в `mock-data-repository.js`:

```js
loadAppListDelegate = function loadAppList(userId, categoryId, initData, successCallback, failCallback) {
    let returnList = [];
    for (app of stubApps) {
        let userApp = { ...app };
        userApp.fav = stubUserFavorites[app.id];
        returnList.push(userApp);
    }
    successCallback(returnList);
}
```

Такая архитектура позволяет быстро разрабатывать прототипы фокусируясь в первую очередь на то, как выглядит приложение. У данного подхода есть ряд минусов: необходимо писать дополнительный код на каждый запрос для сервера, нет возможности валидации пользовательских данных. 

### Локальный backend

Запуск локального backend наиболее предпочтителен при активной разработке приложения. Запустить локальный backend можно двумя способами.

#### Запуск из командной строки

Самым простым способом является запуск через командную строку из дирректории `backend`. Перед тем, как запустить сервер, нам нужно установить переменную окружения `TELEGRAM_BOT_TOKEN` передав туда токен нашего бота, который мы получили при его создании. Это необходимо для корректной валидации данных, которые будут приходить к нам на сервер. Для установки переменной нужно в терминале выполнить следующую команду (macOS, linux):

```bash
export TELEGRAM_BOT_TOKEN="your token here"
```

После установки токена к переменную окружения нужно запустить сам сервер, выполнив в терминале следующую команду (macOS, linux):

```bash
./gradlew runFatJar
```

Если всё выполнено верно, в консоли отобразится стартовые лог с информацией об инициализации:

```
[main] INFO  Application - Autoreload is disabled because the development mode is off.
[main] DEBUG Application - Repository initialization started
[main] DEBUG Application - Repository initialization finished
[main] INFO  Application - Telegram bot token loaded, hash: 1979904964
[DefaultDispatcher-worker-1] TRACE i.ktor.client.plugins.HttpPlainText - Adding Accept-Charset=UTF-8 to https://api.ipify.org
[main] INFO  Application - Application started in 0.379 seconds.
[DefaultDispatcher-worker-4] INFO  Application - Responding at http://0.0.0.0:8080

```

В этом логе нас интересует 2 значения. Убедитесь, что `Telegram bot token loaded, hash:` не равен `0`. Если там `0`, проверьте ещё раз команду установки переменной среды. Второе значение - локальный адрес нашего сервера, он располагается после строки `Application - Responding at`. В приведённом выше логе адресом нашего сервера является `http://0.0.0.0:8080`. 

#### Запуск из IDE

Второй способ требует наличия [Intellij Idea Community Edition](https://www.jetbrains.com/help/idea/installation-guide.html). Для начала необходимо открыть проект `backend`. В первый раз это нужно сделать из меню IDE `File->Open...` и выбрать файл `build.gradle.kts`. При первом открытии IDE сгенерирует папку `.idea` которая будет указывать IDE, что текущая дирректория является проектом и в дальнейшем можно будет открывать сразу папку, а не файл `build.gradle.kts`.

Необходимо дождаться окончания синхронизации проекта и открыть в IDE файл `Application.kt` находящийся по пути `src/main/kotlin/io/github/landarskiy/Application.kt`. Слева от метода `fun main(args: Array<String>)` будет зеленая стрелочка, которую необходимо нажать, чтобы запустить проект прямо в IDE.

При первом запуске в локах возле Telegram bot token будет значение `0`. Это из-за того, что мы не установили переменную окружения. Следуя этой [инструкции](https://www.jetbrains.com/help/objc/add-environment-variables-and-program-arguments.html#add-environment-variables) добавьте значение для переменной `TELEGRAM_BOT_TOKEN` и перезапустите сервер, теперь значение должно быть отличным от `0`.

#### Обновление frontend

Для того, чтобы наше приложение отправляло запрос именно на наш сервер, откройте файл `/webapp/config.json` и замените `serverUrl` на адрес локального сервера. После изменений файл `config.json` должен выглядеть следующим образом:

```js
const configuration = {
    serverUrl: "http://0.0.0.0:8080"
}
```

Теперь откройте `/webapp/index.html` в своём браузере, вы должны увидеть страницу приложения, а влогах сервера должны отобразиться запросы за контентом следующего вида:

```
[eventLoopGroupProxy-4-1] TRACE io.ktor.routing.Routing - Trace for [app, list]
/, segment:0 -> SUCCESS @ /
  /app, segment:1 -> SUCCESS @ /app
    /app/list, segment:2 -> SUCCESS @ /app/list
      /app/list/(method:POST), segment:2 -> SUCCESS @ /app/list/(method:POST)
    /app/details, segment:1 -> FAILURE "Selector didn't match" @ /app/details
    /app/rating, segment:1 -> FAILURE "Selector didn't match" @ /app/rating
  /user, segment:0 -> FAILURE "Selector didn't match" @ /user
Matched routes:
  "" -> "app" -> "list" -> "(method:POST)"
Route resolve result:
  SUCCESS @ /app/list/(method:POST)
```

### Production backend

Первый метод удобен для проверки того, как приложение выглядит в Telegram, но не позволяет нормально проверить бизнес-логику. Второй метод удобен для активной разработки, но не позволяет проверить корректность отображения приложения в Telegram. Чтобы посмотреть на целостную картину нам необходимо опубликовать наш сервер на одном из хостингов.

К сожалению, на рынке не существует бесплатных Java хостингов, однако можно найти относительно недорогие, которые позволяют за разумные деньги (менее 10$ в месяц) разместить ваш сервер. Конечно, можно поднять локальные сервер и это будет условно бесплатно, однако это выходит за рамки нашего примера.

Пользуясь [официальной инструкцией](https://ktor.io/docs/heroku.html) разместите ваш экземпляр сервера в [Heroku](https://dashboard.heroku.com/). Из-за того, что код нашего сервера расположен не в корне, понадобится дополнительная настройка окружения, чтобы Heroku увидел наш проект. Воспользуйтесь инструкцией и установите [subdir-heroku-buildpack](https://elements.heroku.com/buildpacks/timanovsky/subdir-heroku-buildpack). 

Пользуясь [инструкцией](https://devcenter.heroku.com/articles/config-vars#using-the-heroku-dashboard), уставновите в Heroku Dashboard переменную окружения `TELEGRAM_BOT_TOKEN`. 

После этого запустите ваше приложение и [проверьте логи](https://devcenter.heroku.com/articles/logging#view-logs-with-the-heroku-dashboard), в них должна содержаться та же информация, что и при запуске локального сервера. Воздмите оттуда адрес вашего сервера и обновите `config.json`, он должен выглядеть похожим образом:

```js
const configuration = {
    serverUrl: "https://tgminiapp-65728c571d53.herokuapp.com"
}
```
